# JavaScript Style Guide

## Whitespace

  * Use tabs, not spaces.

    ```js
    function bad () {
    ····return 'four spaces';
    }

    function good () {
    ————return 'single tab';
    }
    ```

    **Note**: Enable invisible characters in your text editor or IDE to avoid introducing mixed indentation.

  * Avoid introducing whitespace at the end of a line.

    ```js
    // Bad
    const problem = 'extra spaces';····↵

    // Good
    const noProblem = 'spaces gone';↵
    ```

    **Note**: Enabling invisible characters will help here, too. Your text editor or IDE may also be able to remove whitespace at the end of lines automatically.

  * Use spaces between operators.

    ```js
    // Bad
    const squashed=Math.PI*r*r;

    // Good
    const roomy = Math.PI * r * r;
    ```

  * Prefix, postfix and unary operators do not need to be spaced.

    ```js
    // Bad
    console.log(- x);
    console.log(y ++);
    console.log(-- z);

    // Good
    console.log(-x);
    console.log(y++);
    console.log(--z);
    ```

  * Do not add spaces inside parentheses.

    ```js
    // Bad
    console.log( 'Hello world' );

    // Good
    console.log('Hello world');
    ```

  * Do not add spaces inside square brackets.

    ```js
    // Bad
    [ 'Foo' ];

    // Good
    ['Bar'];
    ```

  * Add spaces inside braces and after colons.

    ```js
    // Bad
    {foo:'bar'};

    // Good
    { foo: 'bar' }
    ```

  * Add spaces after commas.

    ```js
    // Bad
    fn([1,2,3],'a','b','c');

    // Good
    fn([1, 2, 3], 'a', 'b', 'c');
    ```

  * Use spaces around keywords, argument lists and conditions.

    ```js
    // Bad
    function squashed(x){
        if(x){
            return typeof(x);
        }
    }

    // Good
    function roomy (x) {
        if (x) {
            return typeof x;
        }
    }
    ```

## Strings

  * Use `String()` to coerce values into strings.

    ```js
    const maybeString = 123;

    // Bad
    const avoid = maybeString + '';

    // Good
    const prefer = String(maybeString);
    ```

  * Avoid using `#toString()` if possible.

    ```js
    const input = null;

    // Bad
    input.toString() // TypeError: Cannot read property 'toString' of null

    // Good
    String(input); // => null
    ```

    **Note**: `String()` invokes `#toString()` if it is available.

    ```js
    class Example {
        toString () {
            return 'Hello world';
        }
    }

    String(new Example()); // => 'Hello world'
    ```

  * Do not use the `new` keyword when initializing a string.

    ```js
    const response = 123;
    let result;

    // Bad
    result = new String(response);
    typeof result; // => 'object'

    // Good
    result = String(response);
    typeof result; // => 'string'
    ```

  * Use single quotes for strings. Escape single quotes inside the string with a backslash.

    ```js
    // Bad
    const avoid = "What's your name?";

    // Good
    const prefer = 'My name\'s Superman';
    ```

  * Try and use template strings to concatenate values.

    ```js
    const foo = 'foo';
    const bar = 'bar';
    let result;

    // Bad
    result = [foo, ' - ', bar].join('');

    // OK
    result = foo + ' - ' + bar;

    // Good
    result = `${foo} - ${bar}`;
    ```

    ['Template strings' on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings).

  * Use only references in template strings. Avoid using complex statements.

    ```js
    // Bad
    const ugly = `HELLO ${this.get('name').toUpperCase()}`;

    // Good
    const name = this.get('name').toUpperCase();
    const pretty = `HELLO ${name}`;

    // OK
    const result = 'HELLO ${this.name}';
    ```

  * Avoid using template strings where not necessary.

    ```js
    // Unnecessary
    const foo = `Foo`;

    // Better
    const bar = 'Bar';
    ```

## Numbers

  * Use `Number()` to coerce values into numbers where possible. This pattern is preferred for numeric values generated by other systems (e.g. via APIs).

    ```js
    const response = '123';
    let result;

    // Bad
    result = response + 0;

    // Bad
    result = +response;

    // Bad
    result = response >> 0;

    // Better
    result = parseInt(response);

    // Best
    result = Number(response);
    ```

  * Do not use the `new` keyword when initializing a number.

    ```js
    const response = '123';
    let result;

    // Bad
    result = new Number(response);
    typeof result; // => 'object'

    // Good
    result = Number(response);
    typeof result; // => 'number'
    ```

  * Use `Number()` if you _expect_ a value to be a number.

    ```js
    const input = '100x';

    // Bad
    parseInt(input, 10); // => 100

    // Good
    Number(input); // => NaN
    ```

  * Try and use `parseInt()` to coerce user input to numbers. Always use a radix to specify the base you expect the number to be in.

    ```js
    const input = '0x10';
    let result;

    // Bad, implicit radix
    result = Number(input); // => 16

    // Bad, implicit radix
    result = parseInt(input); // => 16

    // Good, explicit radix
    result = parseInt(input, 10); // => 0

    // Good, explicit radix
    result = parseInt(input, 16); // => 16
    ```

  * Use `parseFloat()` only for floating point input in base 10.

    ```js
    const input = '3.14159';
    let result;

    // Bad, loss of precision
    result = parseInt(input, 10); // => 3

    // Bad, unnecessary radix
    result = parseFloat(input, 10); // => 3.14159

    // Bad, ignored radix
    result = parseFloat(input, 16); // => 3.14159

    // Good
    result = parseFloat(input); // => 3.14159
    ```

  * Declare numbers in their original base if appropriate.

    ```js
    // Bad
    const whiteDec = 16777215;

    // Good
    const whiteHex = 0xffffff;

    // Examples
    const dec = 16;
    const hex = 0x10;
    const oct = 0o20; // Introduced in ES6
    const bin = 0b10000; // Introduced in ES6
    ```

  * Do not use the leading-zero pattern of declaring octal numbers. It is unclear and inconsistent with binary and hexadecimal numbers.

    ```js
    // Bad
    const unclear = 010; // => 8

    // Good
    const clear = 0o10; // => 8
    ```

  * Avoid using bitshift operators where possible. Bitshift operators return 32 bit integers instead of an eight byte IEEE 754 floating point number. They will only return whole number values between -2,147,483,648 and 2,147,483,647.

    ```js
    2147483647 >> 0; // => 2147483647
    2147483648 >> 0; // => -2147483648
    2147483649 >> 0; // => -2147483647
    ```

    **Note**: You may be able to use other operators to achieve the intended result:

    ```js
    const x = 10; // 0b1010

    // Bitshift left 5 places
    x << 5;              // 0b100000
    x * Math.pow(2, 5);  // 0b100000

    // Bitshift left 32 places
    x << 32;             // 0b000000000000000000000000000000001 (Bad)
    x * Math.pow(2, 32); // 0b100000000000000000000000000000000 (Good)
    ```

## Booleans

  * Use `Boolean()` to coerce values into booleans. Try and return actual boolean values from any method that declares its return type as boolean.

    ```js
    /**
     * Returns true if `x` and `y` are both truthy, false otherwise.
     * @param {*} x
     * @param {*} y
     * @return {Boolean}
     */
    function and (x, y) {
        let result;

        // Bad
        result = x && y; // and(1, 2) => 2

        // Bad
        result = x && y && true; // and(1, 2) => true

        // Bad
        result = !!(x && y); // and(1, 2) => true

        // Good
        result = Boolean(input); // and(1, 2) => true

        return result;
    }
    ```

  * Do not use the `new` keyword when initializing a boolean.

    ```js
    const falsy = 0;
    let result;

    // Bad
    result = new Boolean(falsy);
    typeof result; // => 'object'

    // Really bad
    result ? 'actual' : 'expected'; // => 'actual'

    // Good
    result = Boolean(falsy);
    typeof result; // => 'boolean'
    ```

## Equality operators

  * Always use strict equality operators.

    ```js
    // Bad
    '1' == 1; // => true

    // Bad
    '1' != 1; // => false

    // Good
    '1' === 1; // => false

    // Good
    '1' !== 1; // => true
    ```

  * Coerce values before comparing them where appropriate.

    ```js
    const x = '1';

    // Bad
    x === 1 || x === '1';

    // Good
    Number(x) === 1; // => true
    ```

  * Be careful when comparing two floating point numbers.

    ```js
    const a = 0.1;
    const b = 0.2;
    const expected = 0.3;
    const actual = a + b; // => 0.30000000000000004
    let eq;

    // Bad
    eq = actual === expected; // => false

    // Good
    eq = Math.abs(actual - expected) < Number.EPSILON; // => true
    ```

    [`Number.EPSILON` on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON). Introduced in ES6.

  * Use `isNaN` to compare with `NaN`

    ```js
    const val = 0 / 0; // => NaN

    // Bad
    val === NaN; // => false

    // Good
    isNaN(val); // => true
    ```

    [`isNaN()` on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isNaN).

  * Keep in mind that comparing object references will not compare their state or value.

    ```js
    [] === []; // => false
    ({} === {}); // => false

    class Example {
        valueOf () {
            return 1;
        }
    }

    new Example() === new Example(); // => false
    ```

## Inequality operators

  * Be careful when comparing with a value that may be `null`.

    ```js
    const a = 5;
    const b = null;

    a >= 0; // => true
    b >= 0; // => true
    ```

  * Keep in mind that comparing object references will compare the objects' values.

    ```js
    class Example {
        constructor (value) {
            this.value = value;
        }
        valueOf () {
            return this.value;
        }
    }

    const foo = new Example(5);
    const bar = new Example(10);
    const baz = new Example(10);

    foo > bar; // => false
    foo < bar; // => true
    foo > 3; // => true
    bar >= baz && bar <= baz; // => true
    ```

  * Note that comparing strings may result in numeric coercion.

    ```js
    '3' > 4; // => false
    '4' > 3; // => true
    ```

## Functions

  * Use function declarations over function expressions where possible.

    ```js
    // Bad
    var add = function () { };

    // Good
    function add () { }
    ```

    **Note**: Function declarations are not statements and as such are not followed by a semicolon.

  * Avoid re-declaring functions.

    ```js
    // Bad, unnecessary re-declaration
    for (let i = 0; i < 10; i++) {
        function square (i) {
            return i * i;
        }
        console.log(square(i));
    }

    // Good, only declared once
    function square (i) {
        return i * i;
    }
    for (let i = 0; i < 10; i++) {
        console.log(square(i));
    }
    ```

  * Document functions where possible. Generally, named functions should all have proper documentation blocks. At the very least, each block should document the expected inputs and outputs (both their purpose and data type). Ideally, a documentation block gives the reader a good idea of what the function will do and how to use it -- without reading any of its code.

  * Give functions descriptive, [imperative](https://en.wikipedia.org/wiki/Imperative_mood) names.

    ```js
    // Bad, name not descriptive
    function fn () {
        return Math.random() < 0.5;
    }

    // Bad, functionality unclear
    function value () {
        // ...
    }

    // Good, name descriptive
    function getRandomBoolean () {
        return Math.random() < 0.5;
    }

    // Good, functionality clear
    function getValue () {
        // ...
    }
    ```

  * Avoid declaring methods which do not depend on `this`. A method is a function declared as a member of an object. If a method does not use `this`, it can probably be defined as a function instead.

    ```js
    class Example {
        constructor () {
            this.foo = 'foo';
        }

        // Unnecessary, does not reference `this`
        logBaz () {
            console.log('baz');
        }

        // Good, references `this`
        logFoo () {
            console.log(this.foo);
        }

        // Good, declared as function
        static logBar () {
            console.log('bar');
        }
    }

    const ex = new Example();
    ex.logFoo(); // => 'foo'
    Example.logBar(); // => 'bar'
    ```

    Notable exceptions are abstract and virtual methods. These may be intentionally stubbed if anticipating child classes to implement those methods.

## Arrow functions

  * Prefer arrow functions over function declarations where possible. Arrow functions are cleaner and do not introduce their own scope.

    ```js
    const input = [1, 2, 3];
    let squared;

    // Bad
    squared = input.map(function (num) {
        return num * num;
    });

    // Better
    squared = input.map((num) => {
        return num * num;
    });

    // Best
    squared = input.map((num) => num * num);
    ```

  * Use parentheses around arguments list even when there is a single argument.

    ```js
    const input = [1, 2, 3];

    // Bad
    input.forEach(x => console.log(x));

    // Good
    input.forEach((x) => console.log(x));
    ```

## Method chaining

  * Split method chains with newlines. This makes functionality clearer, diffs simpler, and [blames](https://git-scm.com/docs/git-blame) easier.

    ```js
    // Bad
    $('.foo').filter('ul').find('li').text((i) => `Item ${i + 1}`);

    // Good
    $('.foo')
        .filter('ul')
        .find('li')
        .text((i) => `Item ${i + 1}`);
    ```

  * Use a leading dot when chaining. Indent chained methods.

    ```js
    // Bad
    Promise.resolve().then(() => {
        const data = getUserInput();
        return asyncFunction1(data);
    }).then(() => asyncFunction2())
    .catch((err) => displayError(err));

    // Good
    Promise.resolve()
        .then(() => {
            const data = getUserInput();
            return asyncFunction1(data);
        })
        .then(() => asyncFunction2())
        .catch((err) => displayError(err));
    ```

  * Limit chain length where possible. It may be clearer to assign intermediary results to a variable.

    ```js
    // Bad
    $('#items')
        .find('.selected')
            .highlight()
            .end()
        .find('.open')
            .updateCount();

    // Good
    const $items = $('#items');
    const $selected = $items.find('.selected');
    const $open = $items.find('.open');
    $selected.highlight();
    $open.updateCount();
    ```
